# 动态开发文档系统

**版本:** 1.0
**日期:** 2023年10月27日
**作者:** (你的名字/团队)

**1. 引言**

- **1.1 背景:**
当前开发团队维护着大量的开发文档，包括架构设计、API 规范、开发指南、操作手册等。随着项目的快速迭代和代码库的演进，文档的更新、重命名和重组变得频繁。现有的文档管理方式（例如，直接基于文件系统或简单的 Wiki）导致以下痛点：
- **链接失效:** 文档间的相互引用（链接）在源文件或目标文件被移动、重命名或删除时，极易失效，导致信息断裂。
- **维护成本高:** 手动查找和修复失效链接耗时耗力，尤其在文档规模庞大时。
- **信息一致性难保证:** 难以追踪某个文档被哪些其他文档所引用，导致更新时可能遗漏相关依赖。
- **版本追踪困难:** 难以清晰地标识和管理文档的废弃与替代关系。
- **1.2 产品目标:**
构建一个“动态开发文档系统”，旨在解决上述问题，实现：
- **链接健壮性:** 确保文档间的引用链接在文档结构调整时保持有效。
- **维护自动化:** 自动化链接的生成、验证和更新提示。
- **内容结构化:** 通过标准化元数据提升文档的可管理性。
- **版本可追溯:** 清晰地管理文档的生命周期（活跃、废弃、替代）。
- **提升效率:** 降低文档维护成本，提高开发者查找和信任信息的效率。
- **1.3 目标用户:**
- **主要用户:**
- 软件开发者（阅读、编写、更新文档）
- 软件架构师（设计、撰写、评审架构文档）
- 技术文档工程师（规划、撰写、维护文档体系）
- DevOps 工程师（集成文档构建到 CI/CD 流程）
- **次要用户:**
- 测试工程师（参考功能规格、API 定义）
- 产品经理（了解技术实现细节）
- 新员工（快速学习项目知识）
- **1.4 核心理念:**
采用“文档即代码 (Docs-as-Code)”的理念，将文档视为项目代码的一部分进行管理，并引入持久化标识符和自动化构建流程来保证文档的动态性和健壮性。
**2. 功能需求 (Features)**

- **2.1 持久化唯一标识符 (Persistent ID)**
- **描述:** 系统中的每一个可独立引用的文档单元（通常对应一个 Markdown 文件）必须被分配一个全局唯一且持久不变的标识符 (ID)。此 ID 不应随文件名或路径的改变而改变。
- **要求:**
- FE-1.1: 支持在文档源文件（如 Markdown Front Matter）中定义 `id` 字段。
- FE-1.2: 构建系统需能在构建时检查并强制 `id` 的唯一性，若发现重复则报错。
- FE-1.3: `id` 格式应简洁、易于引用（例如，`arch-overview`, `api-auth-v2`）。
- **2.2 基于 ID 的内部链接**
- **描述:** 作者在文档中使用特定的、基于 ID 的语法来引用系统内的其他文档，而非易变的相对/绝对路径。
- **要求:**
- FE-2.1: 定义清晰的内部链接语法，例如 `[[target-doc-id]]` 或 `[链接文本](doc:target-doc-id)`。
- FE-2.2: 该语法应能方便地在 Markdown 中书写。
- **2.3 自动化链接解析与生成**
- **描述:** 在文档发布（构建）过程中，系统自动将基于 ID 的内部链接转换为最终用户可访问的、正确的 URL 链接。
- **要求:**
- FE-3.1: 构建脚本需扫描所有文档，提取 `id` 和对应的最终输出路径 (slug/URL)。
- FE-3.2: 构建脚本需维护一个 `id` 到 URL 的映射索引（可基于 SQLite）。
- FE-3.3: 构建脚本需在处理 Markdown 内容时，查找内部链接语法，并使用索引将其替换为标准的 HTML `<a>` 标签，链接文本默认为目标文档的标题（或允许自定义）。
- FE-3.4: 链接解析过程需高效，不应显著拖慢整体构建时间。
- **2.4 链接有效性验证**
- **描述:** 在构建过程中自动检查所有内部链接，确保其指向的 `id` 真实存在。
- **要求:**
- FE-4.1: 如果内部链接指向一个在索引中不存在的 `id`，构建过程必须失败，并明确报告哪个文件的哪个链接无效。
- **2.5 文档状态管理与废弃处理**
- **描述:** 支持标记文档的状态（如：活跃、草稿、已废弃），并能指定已废弃文档的新替代文档。
- **要求:**
- FE-5.1: 支持在文档元数据中定义 `status` 字段 (e.g., `active`, `deprecated`, `draft`)。
- FE-5.2: 支持在文档元数据中定义 `replaced_by` 字段，其值为替代文档的 `id` (当 `status` 为 `deprecated` 时)。
- FE-5.3: 当一个内部链接指向 `status` 为 `deprecated` 的文档时，构建系统应能：
- (选项 A - 推荐) 自动将链接重定向到 `replaced_by` 指定的新文档 URL。
- (选项 B) 在生成的链接旁边显示 "(已废弃)" 标记，并提供一个指向 `replaced_by` 文档的附加链接。
- (选项 C) 构建失败，强制要求作者更新链接。 (具体策略需讨论决定)
- FE-5.4: (可选) 废弃的文档页面本身也应有明显标记，并引导用户前往新文档。
- **2.6 结构化元数据**
- **描述:** 强制或推荐在文档中使用标准化的元数据（Front Matter），以支持系统功能和未来的扩展。
- **要求:**
- FE-6.1: 必须包含的元数据：`id`, `title`。
- FE-6.2: 推荐包含的元数据：`status`, `replaced_by`, `tags`, `version_added`, `last_updated` 等。
- FE-6.3: 构建系统可选择性地验证元数据的完整性或格式。
- **2.7 文档发布与展现 (基于 Docusaurus)**
- **描述:** 提供一个统一的、现代化的 Web 门户来发布和展现所有开发文档。
- **要求:**
- FE-7.1: 利用 Docusaurus 生成静态文档网站。
- FE-7.2: 提供清晰的导航结构（侧边栏、顶部导航）。
- FE-7.3: 提供全文搜索功能。
- FE-7.4: 支持代码高亮、Mermaid 图表等常用技术文档特性。
- FE-7.5: 支持版本化文档 (Docusaurus 内建功能)。
- **2.8 (高级) 自动化文本链接分析 (可选 V2.0)**
- **描述:** 自动分析文档正文中的纯文本，识别可能指向其他文档标题或 ID 的内容，并建议或自动转换为 ID 链接。
- **要求:**
- FE-8.1: 开发 Python 脚本，使用 Markdown 解析库分析文档 AST。
- FE-8.2: 脚本能将文本与已知文档的 `id` 或 `title` (存储在 SQLite 索引中) 进行匹配。
- FE-8.3: 提供报告，列出潜在的、未转换的文本链接。
- FE-8.4: (可选) 提供交互式工具或命令，帮助作者批量转换这些文本为 ID 链接。
- **2.9 (高级) 链接关系数据库与报告 (可选 V2.0)**
- **描述:** 将文档间的链接关系存储到数据库中，用于分析和报告。
- **要求:**
- FE-9.1: 构建脚本在解析链接时，将 `(source_doc_id, target_doc_id)` 关系存入 SQLite 数据库的 `links` 表。
- FE-9.2: 提供脚本或工具，基于此数据库生成报告，例如：
- 哪些文档链接到了特定文档 X？
- 哪些文档是“孤岛”（没有入链或出链）？
- 可视化文档引用关系图。
**3. 非功能性需求 (Non-Functional Requirements)**

- **3.1 易用性 (Usability):**
- 对作者：编写体验接近标准 Markdown，ID 链接语法简单直观。元数据易于理解和填写。
- 对读者：文档网站导航清晰，搜索准确，阅读体验良好。
- **3.2 可靠性 (Reliability):**
- 链接解析和生成必须 100% 准确。
- 链接验证过程必须可靠，能捕获所有无效链接。
- **3.3 性能 (Performance):**
- 文档构建时间应在可接受范围内（具体指标需根据文档规模确定）。
- 生成的文档网站加载速度快。
- **3.4 可维护性 (Maintainability):**
- 自定义的 Python 脚本代码应结构清晰、有注释、易于维护和扩展。
- Docusaurus 配置应遵循最佳实践。
- **3.5 可扩展性 (Scalability):**
- 系统应能支持未来文档数量的增长，而性能不会急剧下降。
- 架构应允许未来添加更多自动化分析或集成功能。
- **3.6 集成性 (Integration):**
- 能够方便地集成到现有的 CI/CD 流程中（例如，在代码合并前自动构建和验证文档）。
**4. 技术架构概要**

- **内容格式:** Markdown + YAML Front Matter
- **版本控制:** Git (文档与代码同仓库)
- **静态站点生成器 (SSG):** Docusaurus v2/v3
- **自动化脚本:** Python 3.x
- **构建时索引/数据库:** SQLite 3
- **核心流程:**

1. 开发者在本地使用 Markdown 编写/修改文档，定义 Front Matter (`id` 等)。
1. 使用 `[[doc-id]]` 语法进行内部链接。
1. 提交到 Git。
1. CI/CD 触发（或本地手动触发）构建流程：
a. Python 脚本扫描所有文档，解析 Front Matter，构建/更新 SQLite 索引 (`id` -> metadata, path)。
b. Python 脚本 (或 Docusaurus 插件) 遍历 Markdown 文件：
i. 验证元数据。
ii. 查找 `[[doc-id]]` 链接。
iii.查询 SQLite 索引，验证 `id` 并获取目标信息。
iv. 处理废弃逻辑。
v. 将 `[[doc-id]]` 替换为 HTML 链接。
vi. (可选) 进行文本链接分析和关系存储。
c. 如果验证通过，调用 Docusaurus 构建命令生成静态网站。
d. 部署静态网站。
1. 用户通过 Web 浏览器访问 Docusaurus 站点。
**5. 成功指标 (Success Metrics)**

- **量化指标:**
- 构建过程中检测到的无效内部链接数量（目标：随时间推移趋近于 0）。
- 因文档链接问题导致的工单或开发者求助次数（目标：显著减少）。
- 文档构建成功率（目标：接近 100%，失败主要由真实的内容错误或无效链接导致）。
- **定性指标:**
- 开发者/用户关于查找信息效率和文档可靠性的满意度调查得分（目标：提升）。
- 技术文档工程师维护文档（特别是重构和更新）的效率反馈（目标：提升）。
**6. 未来考虑 / 超出范围 (Out of Scope for V1.0)**

- **未来考虑:**
- 实现高级功能 FE-8 (文本链接分析) 和 FE-9 (链接关系数据库与报告)。
- 可视化文档依赖图。
- 与项目管理工具（如 JIRA）的集成。
- 更细粒度的内容引用（例如，引用文档中的某个段落或代码块）。
- 基于内容的语义搜索。
- **超出范围 (V1.0):**
- 实时协作编辑功能。
- 复杂的文档审批工作流。
- 非开发类文档的管理（如市场、销售文档）。
- 完整的所见即所得 (WYSIWYG) 编辑器。

---
