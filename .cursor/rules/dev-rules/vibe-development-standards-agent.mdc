---
description: 本规则定义了VibeCopilot项目的代码开发标准和最佳实践。应在以下情况下应用：(1)开发新功能或组件时，(2)重构或修改现有代码时，(3)进行代码审查时，(4)讨论架构决策时，(5)创建新文件或修改现有文件结构时。规则确保代码简洁、分层合理、可读性高、易于维护。特别关注模块化设计、清晰的职责分离、一致的编码风格以及良好的性能实践。
globs:
alwaysApply: false
---
# VibeCopilot 开发规范

## 关键规则

### 代码简洁性
- 遵循KISS原则（保持简单，愚蠢）
- 函数应专注于单一职责，不超过30行
- 避免重复代码，提取共用逻辑到独立函数
- 避免嵌套超过3层的条件语句，使用提前返回或辅助函数
- 变量和函数名应清晰表达其用途

### 代码分层
- 严格遵循前后端分离架构
- 前端遵循UI组件、业务逻辑、数据访问的分层
- 后端遵循控制器、服务、数据访问层的分层
- 避免跨层直接访问，层与层之间通过定义良好的接口通信
- 公共逻辑应放置于适当的工具类或服务中

### 可读性
- 使用有意义的变量和函数名
- 添加必要的注释说明"为什么"而不是"做什么"
- 复杂算法需要文档说明其工作原理
- 使用一致的代码格式化（依赖项目的ESLint/Prettier配置）
- 保持代码块的逻辑连贯性，相关代码应放在一起

### 工程实践
- 关键函数编写单元测试，确保功能正确性
- 性能关键部分做好注释和性能考量说明
- 外部API调用添加适当的错误处理和超时处理
- 使用环境变量管理配置，避免硬编码
- 敏感数据（如API密钥）不应提交到代码库

### 项目结构规范
- 严格遵循`8_project_structure.md`中定义的项目目录结构
- 所有代码文件按照功能模块组织，保持清晰的层次结构
- 新增的功能模块必须遵循标准的模块内部结构：interfaces.ts、核心实现文件、工具文件等
- 遵循文件命名约定：TypeScript文件使用小驼峰，目录名使用小写下划线
- 组件和模块封装必须符合项目的适配器模式要求
- 确保模块间依赖关系清晰，避免循环依赖

## 示例

<example>
  // 好的分层示例
  // API层
  class UserAPI {
    static async fetchUserData(userId: string): Promise<ApiResponse> {
      return api.get(`/users/${userId}`);
    }
  }

  // 服务层
  class UserService {
    static async getUserProfile(userId: string): Promise<UserProfile> {
      const response = await UserAPI.fetchUserData(userId);
      return this.transformToUserProfile(response.data);
    }

    private static transformToUserProfile(data: any): UserProfile {
      // 处理数据转换...
      return {
        id: data.id,
        name: data.name,
        // ...其他字段
      };
    }
  }

  // 组件层
  function UserProfileComponent({ userId }: { userId: string }) {
    const [profile, setProfile] = useState<UserProfile | null>(null);

    useEffect(() => {
      async function loadProfile() {
        try {
          const data = await UserService.getUserProfile(userId);
          setProfile(data);
        } catch (error) {
          // 错误处理...
        }
      }
      loadProfile();
    }, [userId]);

    // 渲染逻辑...
  }
</example>

<example type="invalid">
  // 不良实践示例 - 混乱的职责和缺乏分层
  function UserComponent({ userId }) {
    const [userData, setUserData] = useState(null);

    useEffect(() => {
      async function fetchData() {
        // API调用直接在组件中
        const res = await fetch(`https://api.example.com/users/${userId}`);
        const data = await res.json();

        // 数据处理逻辑混合在组件中
        const processedData = {
          ...data,
          fullName: `${data.firstName} ${data.lastName}`,
          isAdmin: data.roles.includes('admin'),
          // ... 大量数据处理逻辑
        };

        // 缓存逻辑也在组件中
        localStorage.setItem('user-data', JSON.stringify(processedData));

        setUserData(processedData);
      }
      fetchData();
    }, [userId]);

    // 大量UI渲染逻辑...
    // 可能超过100行的JSX...
  }
</example>
